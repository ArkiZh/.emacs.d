* Abount
This is arki's emacs init config.

I learnt from [[https://github.com/purcell/emacs.d][purcell]] much about how to structure the init files.

* Precondition
#+begin_src emacs-lisp
  ;; Check emacs version
  (let ((minver "26.1"))
    (when (version< emacs-version minver)
      (error "Your Emacs is too old -- this config requires v%s or higher" minver)))
  (let ((tested-ver "27.1"))
    (when (version< emacs-version tested-ver)
      (message "This config has been tested under version %s. But yours is %s. Upgrade if possible." tested-ver emacs-version)))
#+end_src

* Set the most basic default options
** Load packages, and activate them.
#+begin_src emacs-lisp
  ;; Adjust garbage collection thresholds during startup, and thereafter
  ;; In bytes
  (setq gc-cons-threshold (* 1024 1024 1024))
  (add-hook 'emacs-startup-hook
            (lambda () (setq gc-cons-threshold (* 20 1024 1024))))

  ;; Produce backtraces when errors occur: can be helpful to diagnose startup issues
  ;; (setq debug-on-error t)

  ;; Setup mirror from https://elpa.emacs-china.org/
  (require 'package)

  ;;(pp package-enable-at-startup) ;; t
  ;;(pp load-path) ;; For now, equal to subdirs of package-directory-list
  ;; See: the last 6 paragraphs of https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Installation.html#Package-Installation
  ;; your init file should call the function package-initialize. It is up to you to ensure that relevant user options, such as package-load-list (see below), are set up prior to the package-initialize call. This will automatically set package-enable-at-startup to nil, to avoid loading the packages again after processing the init file. 
  (package-initialize)
  ;;(pp load-path) ;; At this time, add subdirs of  package-user-dir to package-directory-list
  ;;(pp package-load-list) ;; (all)
  ;;(pp package-enable-at-startup) ;; nil
#+end_src

** Setup ~custom-file~ location. 
#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+end_src

** Behaviours
#+begin_src emacs-lisp
  ;; 设置utf-8为默认编码格式
  (set-language-environment "UTF-8")

  ;; 取消滚动到底部的报警声
  (setq ring-bell-function 'ignore)

  ;; Enable truncate lines
  (setq-default truncate-lines t)

  ;; 禁止 Emacs 自动生成备份文件
  (setq make-backup-files nil)

  ;; 禁止默认的自动保存
  (setq auto-save-default nil)

  ;; 保存桌面布局
  (desktop-save-mode -1)

  ;; 自动加载修改过的文件
  (global-auto-revert-mode t)

  ;; 记录最近打开过的文件
  ;; (require 'recentf)
  (recentf-mode 1)
  (setq recentf-max-menu-item 300)

  ;; Less typing when emacs asks yes or no
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** UI
#+begin_src emacs-lisp
  ;; Set cursor type to box or bar
  (setq-default cursor-type 'bar)  	;Doesn't take effect by: (setq cursor-type 'bar)

  ;; 关闭启动帮助画面
  (setq inhibit-splash-screen 1)

  ;; 关闭工具栏，tool-bar-mode 即为一个 Minor Mode
  (tool-bar-mode 'toggle)
  ;; 关闭菜单栏
  (menu-bar-mode 'toggle)

  ;; 全屏显示
  ;; (setq initial-frame-alist (quote ((fullscreen . maximized))))
  (toggle-frame-maximized)
  ;; (toggle-frame-fullscreen)

  ;; 关闭文件滑动控件
  (scroll-bar-mode 'toggle)

  ;; 显示行号 仅当编程模式时候
  (add-hook 'prog-mode-hook
            (lambda nil
              (if (version<= "26.0.50" emacs-version )
                  (display-line-numbers-mode)
                (linum-mode 1)))
            )

  ;; 在最下面显示光标在行中的位置
  (column-number-mode 1)

  ;; Set mouse-color
  (when (equal window-system 'x)
    (if (equal (frame-parameter nil 'background-mode) 'light)
        (set-frame-parameter nil 'mouse-color "black")
      (set-frame-parameter nil 'mouse-color "white")
      ))
#+end_src
** Editor
#+begin_src emacs-lisp
  ;; 选中一段文字之后输入一个字符会替换掉你选中部分的文字
  (delete-selection-mode 1)

  ;; 缩进不使用TAB
  ;; Indentation can insert tabs if this is non-nil. Default is t.
  (setq-default indent-tabs-mode nil)
  ;; Distance between tab stops (for display of tab characters), in columns. Default is 8.
  (setq-default tab-width 4)
#+end_src
** Enable disabled things
#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src

* Define my custom common functions
#+begin_src emacs-lisp
  ;;----------------------------------------------------------------------------
  ;; Install package
  ;;----------------------------------------------------------------------------
  (setq package-archives '(("gnu"   . "http://elpa.emacs-china.org/gnu/")
                           ("melpa" . "http://elpa.emacs-china.org/melpa/")))


  (defgroup arki/config nil
    "Manager for my own confgs.")


  (defcustom arki/cache-dir (expand-file-name "arki.cache" user-emacs-directory) "Cache for useful files" :group 'arki/config)
  (make-directory arki/cache-dir t)


  (defcustom arki/site-lisp-dir (expand-file-name "site-lisp" user-emacs-directory)
    "Directory for site lisp. If changed, should add the new value to `load-path' manually."
    :group 'arki/config)
  (make-directory arki/site-lisp-dir t)
  (add-to-list 'load-path arki/site-lisp-dir)


  (defvar arki/package-contents-refreshed nil
    "Indicate whether the package contents has been refreshed.

  If nil: invoke `package-refresh-contents' during `require-package', then set to t, no matter whether the refresh is successful.
  If non-nil: don't invoke `package-refresh-contents' during `require-package.")

  (defvar arki/package-installed-info '(("INSTALLED_BEFORE") ("INSTALLED_NOW") ("FAILED"))
    "Record the installation info of required packages.")

  
  ;; Common functions

  (defun arki/alist-push-value (input_alist key value)
    "Set the given ALIST.
  Operation is done in-place.

  If the key exists: push value to the first position of that key's content.
  If not exists: append the k-v pair to the end of this alist.

  Return: the input_alist."
    (let ((cur_kv (assoc key input_alist)))
      (if cur_kv (setcdr cur_kv (cons value (cdr cur_kv)))
        ;; (message "Unknown key: %s. Now add it with value: %s." key value)
        ;; (setcdr input_alist (copy-alist input_alist))
        ;; (setcar input_alist (list key value))
        (setcdr (last input_alist) (list (list key value)))
        )
      )
    input_alist)

  (defun arki/directory-parent (file-name n)
    "Get parent directory of `file-name' by `n' times"
    (let ((result (directory-file-name (expand-file-name file-name))))
      (dotimes (i n)
        (setq result (directory-file-name (file-name-directory result))))
      result))
  

  (defun refresh-pack-contents ()
    "Refresh package database. And refresh only once."
    (unless arki/package-contents-refreshed
      (message "Refreshing package database...")
      (condition-case err (
                           progn
                           (message "Refreshing package database...")
                           (package-refresh-contents)
                           (message "Refreshing package database finished!")
                           )
        (error
         (message "Failed to refresh package database! ERROR: %S" err))
        )
      (setq arki/package-contents-refreshed t)
      ))


  (defun require-pack (pack &optional skip-load)
    "Install the given PACKAGE.
  And execute require PACKAGE if newly installed, to avoid requiring it manually.

  If installed successfully, return t, else return nil"
    (if (package-installed-p pack) (progn
                                     (arki/alist-push-value arki/package-installed-info "INSTALLED_BEFORE" pack)
                                     (when (not skip-load)
                                       (require pack))
                                     t)
      (refresh-pack-contents)
      (message "Package: %s installing..." pack)
      (condition-case err (progn
                            (package-install pack)
                            (arki/alist-push-value arki/package-installed-info "INSTALLED_NOW" pack)
                            (message "Package: %s installed!" pack)
                            (when (not skip-load)
                              (require pack)
                              (message "Package: %s loaded!" pack))
                            t)
        (error
         (arki/alist-push-value arki/package-installed-info "FAILED" pack)
         (message "Package `%S' failed to install! ERROR: %S" pack err)
         nil)
        )
      ))

  (defun require-packs (pack &rest packs)
    "Insall the given packs.

  If all installed successfully, return t, else return nil"
    (if (not packs)
        (require-pack pack)
      (push pack packs)
      (let ((all-installed t))
        (dolist (cur-pack packs)
          (setq all-installed (and all-installed (require-pack cur-pack))))
        all-installed))
    )

  ;;----------------------------------------------------------------------------
  ;; Set key binding
  ;;----------------------------------------------------------------------------
  (defvar arki/key-bindings '((global))
    "Record customize key-bindings.")

  (define-prefix-command 'arki/prefix-keymap)
  (global-set-key (kbd "M-SPC") 'arki/prefix-keymap)

  (defun arki/define-key (key command &optional keymap)
    "Set key binding, and record the binding.
  If keymap is not provided, will use global-set-key.
  If keymap is provided, you should add quote before it."
    (interactive)
    (if keymap
        (progn
          (define-key (eval keymap) (kbd key) command)
          (arki/alist-push-value arki/key-bindings keymap (list key command))
          )
      (global-set-key (kbd key) command)
      (arki/alist-push-value arki/key-bindings 'global (list key command))
      )
    )

  ;;----------------------------------------------------------------------------
  ;; Delete the current file
  ;;----------------------------------------------------------------------------
  (defun arki/delete-this-file-and-buffer ()
    "Delete the current file, and kill the buffer."
    (interactive)
    (unless (buffer-file-name)
      (error "No file is currently being edited"))
    (when (yes-or-no-p (format "Really delete '%s'?"
                               (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name))
      (kill-this-buffer)))

  (arki/define-key "k" 'arki/delete-this-file-and-buffer 'arki/prefix-keymap)

  ;;----------------------------------------------------------------------------
  ;; Rename the current file
  ;;----------------------------------------------------------------------------
  (defun arki/rename-this-file-and-buffer (new-name)
    "Rename both current buffer and file to NEW-NAME."
    (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (unless filename
        (error "Buffer '%s' is not visiting a file!" name))
      (progn
        (when (file-exists-p filename)
          (rename-file filename new-name 1))
        (set-visited-file-name new-name)
        (rename-buffer new-name))))

  (arki/define-key "r" 'arki/rename-this-file-and-buffer 'arki/prefix-keymap)

  ;;----------------------------------------------------------------------------
  ;; 快速打开配置文件
  ;;----------------------------------------------------------------------------
  (defun arki/open-init-file()
    "Open init file.

  The file is named init.el under `user-emacs-directory'."
    (interactive)
    (find-file (expand-file-name "init.el" user-emacs-directory)))

  (defun arki/open-alias()
    "Open alias files.

  If the alias is defined, open it.
  Else, define it now, then open it."
    (interactive)
    ;; TODO
    )


  ;; (arki/define-key "<f2>" 'arki/open-init-file)


  ;;----------------------------------------------------------------------------
  ;; 根据需要以sudo打开文件
  ;;----------------------------------------------------------------------------
  (defun arki/sudo-open-file()
    "Open file with sudo privilege"
    (interactive)
    (if (memq system-type '(cygwin darwin gnu gnu/linux))
        (let* ((cur-file (buffer-file-name))
               (file-path (ido-read-file-name "Sudo open: " nil (buffer-file-name))))
          (find-file (concat "/sudo::" file-path))
          )
      (message "Can't execute sudo for system: [%s]" system-type)
      )
    )


  ;;----------------------------------------------------------------------------
  ;; 调整buffer中的缩进
  ;;----------------------------------------------------------------------------
  (defun arki/indent-region-or-buffer()
    "Indent the region if selected, otherwise the whole buffer."
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Region indented."))
        (progn
          (indent-region (point-min) (point-max))
          (message "Buffer indented.")))))

  (arki/define-key "C-M-\\" 'arki/indent-region-or-buffer)

  ;;----------------------------------------------------------------------------
  ;; 复制或剪切当前行
  ;;----------------------------------------------------------------------------
  (defun arki/copy-or-kill-current-line (arg)
    "If arg equals 4, kill.
  Else copy."
    (interactive "p")
    (save-mark-and-excursion
      (if (= arg 4)
          (progn
            (kill-region (line-beginning-position) (line-end-position))
            (message "Current line killed."))
        (kill-ring-save (line-beginning-position) (line-end-position))
        (message "Current line copied."))))

  (arki/define-key "l" 'arki/copy-or-kill-current-line 'arki/prefix-keymap)

  ;;----------------------------------------------------------------------------
  ;; 将多行的段落合并成一行
  ;;----------------------------------------------------------------------------
  ;; https://stackoverflow.com/questions/6707758/inverse-of-m-q-an-unfill-paragraph-function
  (defun arki/unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          ;; This would override `fill-column' if it's an integer.
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))

  ;; 将多行的段落合并成一行
  (arki/define-key "M-Q" 'arki/unfill-paragraph)

  
  ;;----------------------------------------------------------------------------
  ;; Site lisp utils
  ;;----------------------------------------------------------------------------
  ;; Learnt from purcel's config.
  ;; https://github.com/purcell/emacs.d


  ;; It seems only need to add site-lisp root dir to load-path, so comment this function out.
  ;; But it turns out that I'm wrong. If not append the subdir path to load path,
  ;; the el file in it won't compile successfully.
  ;; Now I add this logic into require-pack-local, only add the subdir which is needed.

  ;; (defun arki/add-subdirs-to-load-path (parent-dir)
  ;;   "Add every non-hidden subdir of PARENT-DIR to `load-path'."
  ;;   (let ((default-directory parent-dir))
  ;;     (dolist (cur-dir (directory-files (expand-file-name user-emacs-directory) t "^[^\\.]"))
  ;;       (when (file-directory-p cur-dir)
  ;; 	(setq load-path (append (list cur-dir) load-path))))))


  ;; Utilities for grabbing upstream libs
  (defun arki/site-lisp-dir-for (name)
    (expand-file-name (symbol-name name) arki/site-lisp-dir))


  (defun arki/site-lisp-library-el-path (name)
    "Locate el file path in site lisp directory.

  First search file in `arki/site-lisp-dir', if not found here, give the path in subdir."
    (let* ((el-name (format "%s.el" name))
           (first-file (expand-file-name el-name arki/site-lisp-dir)))
      (if (file-exists-p first-file)
          first-file
        (expand-file-name el-name (arki/site-lisp-dir-for name)))))


  (defun arki/download-site-lisp-el-file (name url)
    "Dowload el file from url.

  Return file path if success, else return nil."
    (let* ((dir (arki/site-lisp-dir-for name))
           (dir-exists (file-directory-p dir)))
      (message "Downloading %s from %s" name url)
      (unless dir-exists (make-directory dir t))
      (let ((el-file (arki/site-lisp-library-el-path name)))
        (condition-case err (progn
                              (url-copy-file url el-file t nil)
                              el-file)
          (error
           (warn "Failed to download %s! ERROR: %S" name err)
           (unless dir-exists (delete-directory dir t))
           nil)))))


  (defun site-lisp-library-loadable-p (name)
    "Return whether or not the library `name' can be loaded from a
  source file under `arki/site-lisp-dir'"
    (file-exists-p (arki/site-lisp-library-el-path name)))


  (defun require-pack-local (name &optional ensure url)
    "Install package from url.

  TODO: Need to add feature: 
  1. Need to support the case: url is a git repo.
  2. In the case el file's name is different from its dir: need to specify the target dir, and load specific el file. 
  2. The switch to skip compile stage.


  If it's already downloaded before, compile it if necessary, then require it.
  If not found, download it if `ensure' is t, otherwise ignore this package."
    (if (site-lisp-library-loadable-p name)
        (let ((el-file (arki/site-lisp-library-el-path name)))
          ;; Add this file's parent dir to load-path, to avoid compiling error.
          (add-to-list 'load-path (file-name-directory el-file))
          ;; Compile this el file if it hasn't been compiled.
          (if (file-exists-p (byte-compile-dest-file el-file))
              (load (byte-compile-dest-file el-file))
            (message "Compile file: " el-file)
            (byte-compile-file el-file t)))
      (if ensure
          (if url
              (progn (message "Local package not found: %s, download now." name)
                     (if (arki/download-site-lisp-el-file name url)
                         (require-pack-local name)
                       (warn "Require local pack failed for %s" name)
                       nil))
            (warn "Local package not found: %s, and no download url is provided!" name)
            nil)
        (message "Local package is not found: %s, ignore it." name)
        nil)))
#+end_src
* Basic config without any extra packages
** Config as a text editor

** Config font

* Setup extra packages or features
** Set melpa and mirror
#+begin_src emacs-lisp
  (setq package-archives '(("gnu"   . "https://elpa.emacs-china.org/gnu/")
                           ("melpa" . "https://elpa.emacs-china.org/melpa/")))

  ;; Import new GNU ELPA keys (if any) into package.el’s keyring.
  (require-pack 'gnu-elpa-keyring-update)
#+end_src
** dired
** ui
** env
** dashboard
** screensaver
** which-key
** auto-complete
** elisp
** org
** project-tools
** filetypes-support
** input-method
** fonts
** auto-save
** ibuffer
** layout
** help-info
** dictionary
** python
** wsl
** eaf

* Need review
#+begin_src emacs-lisp
  ;; Bookmarks
  (setq bookmark-default-file (expand-file-name "bookmarks" arki/cache-dir))
  (setq bookmark-save-flag 1)
#+end_src
* Load customized configuritions
#+begin_src emacs-lisp
  ;;----------------------------------------------------------------------------
  ;; Load variables configured via the interactive 'customize' interface
  ;;----------------------------------------------------------------------------
  (when (file-exists-p custom-file)
    (load custom-file))

  (message "My init file ends here!")
#+end_src
